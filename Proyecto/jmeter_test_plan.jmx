<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Sistema Biblioteca Distribuida" enabled="true">
      <stringProp name="TestPlan.comments">Plan de pruebas para sistema distribuido de préstamo de libros</stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="GC_HOST" elementType="Argument">
            <stringProp name="Argument.name">GC_HOST</stringProp>
            <stringProp name="Argument.value">localhost</stringProp>
          </elementProp>
          <elementProp name="GC_PORT" elementType="Argument">
            <stringProp name="Argument.name">GC_PORT</stringProp>
            <stringProp name="Argument.value">5556</stringProp>
          </elementProp>
        </collectionProp>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath">${JMETER_HOME}/lib/jeromq-0.6.0.jar</stringProp>
    </TestPlan>
    <hashTree>
      
      <!-- PS-01: 4 Procesos Solicitantes con 20 solicitudes cada uno -->
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="PS-01: 4 PS x 20 Solicitudes" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControllerGui" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">20</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">4</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Solicitud Préstamo ZMQ" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import org.zeromq.ZMQ
import org.zeromq.ZContext

def context = new ZContext()
def requester = context.createSocket(ZMQ.REQ)

try {
    // Conectar al GC
    requester.connect("tcp://${GC_HOST}:${GC_PORT}")
    
    // Lista de libros para probar
    def libros = ["978-0134685991", "978-0596009205", "978-0321573513", "978-1449355739"]
    def libro = libros[new Random().nextInt(libros.size())]
    def usuario = "user_jmeter_" + Thread.currentThread().getId()
    
    // Enviar solicitud de PRESTAMO
    def request = "PRESTAMO|${libro}|${usuario}"
    def startTime = System.currentTimeMillis()
    
    requester.send(request)
    log.info("Enviado: " + request)
    
    // Recibir respuesta
    def response = requester.recvStr()
    def endTime = System.currentTimeMillis()
    
    SampleResult.setResponseData(response, "UTF-8")
    SampleResult.setResponseOK()
    SampleResult.setLatency(endTime - startTime)
    
    if (response.startsWith("OK")) {
        SampleResult.setSuccessful(true)
        SampleResult.setResponseMessage("Préstamo exitoso")
    } else {
        SampleResult.setSuccessful(false)
        SampleResult.setResponseMessage("Préstamo fallido: " + response)
    }
    
} catch (Exception e) {
    SampleResult.setSuccessful(false)
    SampleResult.setResponseMessage("Error: " + e.getMessage())
    log.error("Error en solicitud", e)
} finally {
    requester.close()
    context.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        
        <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="Pausa entre solicitudes" enabled="true">
          <stringProp name="ConstantTimer.delay">200</stringProp>
        </ConstantTimer>
        <hashTree/>
        
      </hashTree>
      
      <!-- DES-01: 4 PS por sede con medición de tiempo -->
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="DES-01: Tiempo Respuesta 4 PS" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControllerGui" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">20</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">4</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.duration">120</stringProp>
        <stringProp name="ThreadGroup.delay">0</stringProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Solicitud Mixta" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="script">import org.zeromq.ZMQ
import org.zeromq.ZContext

def context = new ZContext()
def requester = context.createSocket(ZMQ.REQ)

try {
    requester.connect("tcp://${GC_HOST}:${GC_PORT}")
    
    def operaciones = ["PRESTAMO", "DEVOLUCION", "RENOVACION", "INFO"]
    def libros = ["978-0134685991", "978-0596009205", "978-0321573513"]
    
    def operacion = operaciones[new Random().nextInt(operaciones.size())]
    def libro = libros[new Random().nextInt(libros.size())]
    def usuario = "jmeter_" + Thread.currentThread().getId()
    
    def request = "${operacion}|${libro}|${usuario}"
    def startTime = System.currentTimeMillis()
    
    requester.send(request)
    def response = requester.recvStr()
    
    // Para operaciones asíncronas, esperar resultado
    if ((operacion == "DEVOLUCION" || operacion == "RENOVACION") && response.startsWith("OK")) {
        def parts = response.split("\\|")
        if (parts.length >= 3) {
            def messageId = parts[2]
            Thread.sleep(2000)
            requester.send("STATUS|" + messageId)
            response = requester.recvStr()
        }
    }
    
    def endTime = System.currentTimeMillis()
    
    SampleResult.setResponseData(response, "UTF-8")
    SampleResult.setLatency(endTime - startTime)
    SampleResult.setSuccessful(response.contains("OK") || response.contains("SUCCESS"))
    
} catch (Exception e) {
    SampleResult.setSuccessful(false)
    SampleResult.setResponseMessage("Error: " + e.getMessage())
} finally {
    requester.close()
    context.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
      </hashTree>
      
      <!-- DES-02: 10 PS por sede -->
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="DES-02: Escalabilidad 10 PS" enabled="false">
        <stringProp name="ThreadGroup.num_threads">10</stringProp>
        <stringProp name="ThreadGroup.ramp_time">2</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController">
          <stringProp name="LoopController.loops">20</stringProp>
        </elementProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.duration">120</stringProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Carga Alta" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="script">import org.zeromq.ZMQ
import org.zeromq.ZContext

def context = new ZContext()
def requester = context.createSocket(ZMQ.REQ)

try {
    requester.connect("tcp://${GC_HOST}:${GC_PORT}")
    requester.setReceiveTimeOut(5000)
    
    def libro = "978-013468599" + (new Random().nextInt(5) + 1)
    def usuario = "load_test_" + Thread.currentThread().getId()
    
    def request = "PRESTAMO|${libro}|${usuario}"
    
    requester.send(request)
    def response = requester.recvStr()
    
    SampleResult.setResponseData(response ?: "Timeout", "UTF-8")
    SampleResult.setSuccessful(response != null && response.startsWith("OK"))
    
} catch (Exception e) {
    SampleResult.setSuccessful(false)
    SampleResult.setResponseMessage(e.getMessage())
} finally {
    requester.close()
    context.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
      </hashTree>
      
      <!-- Listeners para resultados -->
      <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="Summary Report" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename">resultados_jmeter.csv</stringProp>
      </ResultCollector>
      <hashTree/>
      
      <ResultCollector guiclass="GraphVisualizer" testclass="ResultCollector" testname="Graph Results" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
          </value>
        </objProp>
      </ResultCollector>
      <hashTree/>
      
    </hashTree>
  </hashTree>
</jmeterTestPlan>
